Backport of https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1309 to fix lag on NVIDIA devices such as serw12.
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -189,7 +189,7 @@
     {
       frame_clock->last_presentation_time_us = presentation_time_us;
     }
-  else
+  else if (presentation_time_us != 0)
     {
       g_warning_once ("Bogus presentation time %" G_GINT64_FORMAT
                       " travelled back in time, using current time.",
--- a/cogl/cogl/cogl-onscreen-private.h
+++ b/cogl/cogl/cogl-onscreen-private.h
@@ -72,6 +72,8 @@
                                * cogl_onscreen_swap_buffers() */
   GQueue pending_frame_infos;
 
+    guint timeout_source_id;
+
   void *winsys;
 };
 
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -155,6 +155,13 @@
   _cogl_closure_list_disconnect_all (&onscreen->frame_closures);
   _cogl_closure_list_disconnect_all (&onscreen->dirty_closures);
 
+  if (onscreen->timeout_source_id)
+    {
+      g_source_remove (onscreen->timeout_source_id);
+      onscreen->timeout_source_id = 0;
+    }
+
+
   while ((frame_info = g_queue_pop_tail (&onscreen->pending_frame_infos)))
     cogl_object_unref (frame_info);
   g_queue_clear (&onscreen->pending_frame_infos);
@@ -290,6 +297,60 @@
   _cogl_onscreen_queue_dispatch_idle (onscreen);
 }
 
+static void
+cogl_onscreen_schedule_presentation_events (CoglOnscreen *onscreen);
+
+static gboolean
+cogl_onscreen_emit_presentation_event_now (gpointer user_data)
+{
+  CoglOnscreen *onscreen = COGL_ONSCREEN (user_data);
+  CoglFrameInfo *info;
+
+  info = g_queue_pop_head (&onscreen->pending_frame_infos);
+  _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
+  _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
+  cogl_object_unref (info);
+
+  onscreen->timeout_source_id = 0;
+
+  if (!g_queue_is_empty (&onscreen->pending_frame_infos))
+    cogl_onscreen_schedule_presentation_events (onscreen);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+cogl_onscreen_schedule_presentation_events (CoglOnscreen *onscreen)
+{
+  CoglFrameInfo *info;
+
+  info = g_queue_peek_head (&onscreen->pending_frame_infos);
+
+  if (!info || onscreen->timeout_source_id)
+    return;
+
+  if (info->presentation_time)
+    {
+      CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+      CoglContext *context = cogl_framebuffer_get_context (framebuffer);
+      int64_t now_ns = cogl_get_clock_time (context);
+
+      if (info->presentation_time > now_ns)
+        {
+          int64_t delay_ns = info->presentation_time - now_ns;
+          unsigned int delay_ms = (delay_ns + 999999) / 1000000;
+
+          onscreen->timeout_source_id =
+            g_timeout_add (delay_ms,
+                           cogl_onscreen_emit_presentation_event_now,
+                           onscreen);
+          return;
+        }
+    }
+
+  cogl_onscreen_emit_presentation_event_now (onscreen);
+}
+
 void
 cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                         const int *rectangles,
@@ -316,18 +377,7 @@
                                     COGL_BUFFER_BIT_STENCIL);
 
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT))
-    {
-      CoglFrameInfo *info;
-
-      g_warn_if_fail (onscreen->pending_frame_infos.length == 1);
-
-      info = g_queue_pop_tail (&onscreen->pending_frame_infos);
-
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
-
-      cogl_object_unref (info);
-    }
+    cogl_onscreen_schedule_presentation_events (onscreen);
 
   onscreen->frame_counter++;
 }
@@ -372,18 +422,7 @@
                                     COGL_BUFFER_BIT_STENCIL);
 
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT))
-    {
-      CoglFrameInfo *info;
-
-      g_warn_if_fail (onscreen->pending_frame_infos.length == 1);
-
-      info = g_queue_pop_tail (&onscreen->pending_frame_infos);
-
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
-
-      cogl_object_unref (info);
-    }
+    cogl_onscreen_schedule_presentation_events (onscreen);
 
   onscreen->frame_counter++;
 }
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -1911,11 +1911,55 @@
         _cogl_winsys_wait_for_vblank (onscreen);
     }
 
-  glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
-
   if (have_counter)
-    glx_onscreen->last_swap_vsync_counter =
-      _cogl_winsys_get_vsync_counter (context);
+    {
+      uint32_t vsync_count_before, vsync_count_after;
+
+      vsync_count_before = _cogl_winsys_get_vsync_counter (context);
+      glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+      vsync_count_after = _cogl_winsys_get_vsync_counter (context);
+
+      glx_onscreen->last_swap_vsync_counter = vsync_count_after;
+
+      /* If we don't have presentation event support (Nvidia) but the swap
+       * blocked then right now is a pretty good estimate of the presentation
+       * time of the frame from nbuffers-1 swaps ago.
+       */
+      if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT) &&
+          vsync_count_after != vsync_count_before)
+        {
+          CoglFrameInfo *frame_info;
+
+          frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
+          g_warn_if_fail (frame_info != NULL);
+
+          if (frame_info)
+            {
+              const int64_t one_second_ns = 1000000000;
+              float refresh_rate;
+              int64_t refresh_interval_ns;
+
+              refresh_rate = cogl_output_get_refresh_rate (xlib_onscreen->output);
+              refresh_interval_ns = one_second_ns / refresh_rate;
+
+              /* If the current time is when the swap at the head of the queue
+               * presented, then the expected presentation time of our most
+               * recent swap at the tail of the queue is nbuffers-1 frames
+               * later. However since we can't reliably know the value of
+               * nbuffers, or the semantics of whether the driver will use them
+               * FIFO, we assume the minimum which is two buffers. Thus the
+               * expected presentation time of the most recent swap is one
+               * frame interval from now:
+               */
+              frame_info->presentation_time =
+                _cogl_winsys_get_clock_time (context) + refresh_interval_ns;
+            }
+        }
+    }
+  else
+    {
+      glx_renderer->glXSwapBuffers (xlib_renderer->xdpy, drawable);
+    }
 
   set_frame_info_output (onscreen, xlib_onscreen->output);
 }
